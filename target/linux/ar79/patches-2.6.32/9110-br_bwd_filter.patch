Index: linux-2.6.32.27/include/linux/netdevice.h
===================================================================
--- linux-2.6.32.27.orig/include/linux/netdevice.h
+++ linux-2.6.32.27/include/linux/netdevice.h
@@ -638,6 +638,13 @@ struct net_device_ops {
 #endif
 };
 
+/* Support to check forwarding filter between LAN/WLAN and WAN.
+ * bits of vid_map[] mean VID of WAN port (eth0)
+ */
+struct packet_fwd_filter {
+	unsigned char vid_map[4096/8]; /* bitwise map: 1: forward, 0: drop */
+};
+
 /*
  *	The DEVICE structure.
  *	Actually, this whole structure is a big mistake.  It mixes I/O
@@ -917,6 +924,25 @@ struct net_device
 	/* max exchange id for FCoE LRO by ddp */
 	unsigned int		fcoe_ddp_xid;
 #endif
+
+       /*
+        * Forwarding filter to drop packets.
+        * bitwise map for VID 0 ~ 4095
+        */
+       struct packet_fwd_filter *pkt_fwd_filter;
+
+       /*
+        * Forwarding group of this deivce.
+        * Forwarding between the same group is not allowed.
+        */
+       unsigned char fwd_grp;
+#if 0
+#define NETDEV_GRP_IGNORE      0 /* ignore the (from, to) relation */
+#define NETDEV_GRP_LAN         1 /* LAN group */
+#define NETDEV_GRP_WAN         2 /* WAN group */
+#define NETDEV_GRP_WLAN        4 /* WLAN group */
+#endif
+
 };
 #define to_net_dev(d) container_of(d, struct net_device, dev)
 
Index: linux-2.6.32.27/include/net/br_pkt_fwd_filter.h
===================================================================
--- /dev/null
+++ linux-2.6.32.27/include/net/br_pkt_fwd_filter.h
@@ -0,0 +1,59 @@
+/*
+ *      Packet forwarding filter for ethernet bridge
+ *
+ * This file contains unpublished documentation and software
+ * proprietary to Cortina Systems Incorporated. Any use or disclosure,
+ * in whole or in part, of the information in this file without a
+ * written consent of an officer of Cortina Systems Incorporated is
+ * strictly prohibited.
+ * Copyright (c) 2010 by Cortina Systems Incorporated.
+ */
+
+#ifndef _BR_PACKET_FORWARD_FILTER_H
+#define _BR_PACKET_FORWARD_FILTER_H
+
+#define BR_PKT_FWD_FT_DRIVER_NAME       "br_pkt_fwd_filter"
+#define BR_PKT_FWD_FT_VLAN_ARRAY_LEN    (4096/8)
+#define BR_PKT_FWD_FT_NAME_LEN          16
+
+#define NETDEV_GRP_IGNORE      0 /* ignore the (from, to) relation */
+#define NETDEV_GRP_LAN         1 /* LAN group */
+#define NETDEV_GRP_WAN         2 /* WAN group */
+#define NETDEV_GRP_WLAN        4 /* WLAN group */
+
+/* IOCTL command of packet forwarding filter */
+typedef enum
+{
+        PKT_FWD_FT_RESET = 1,
+        PKT_FWD_FT_RAW_SET,
+        PKT_FWD_FT_RAW_GET,
+        PKT_FWD_FT_ETH_GRP_SET,
+        PKT_FWD_FT_ETH_GRP_GET,
+        PKT_FWD_FT_ETH_VLAN_SET,
+        PKT_FWD_FT_ETH_VLAN_GET,
+        PKT_FWD_FT_MAX
+} BR_FWD_PKT_FT_CMD_DEF_T;
+
+struct br_fwd_fwd_ft_vlan {
+        unsigned short vid;
+        unsigned char mode; /* 1: forward, 0: drop */
+};
+
+/* structure of parameters for IOCTL command */
+typedef struct {
+        unsigned short cmd;         /* refer to BR_FWD_PKT_FT_CMD_DEF_T */
+
+        char netdev_name[BR_PKT_FWD_FT_NAME_LEN];
+
+        unsigned char fwd_grp;
+
+        union {
+                unsigned char vid_map[BR_PKT_FWD_FT_VLAN_ARRAY_LEN];
+                struct br_fwd_fwd_ft_vlan vlan_mode;
+        };
+
+} BR_FWD_PKT_FT_CMD_T;
+
+
+#endif
+
Index: linux-2.6.32.27/net/8021q/vlan_dev.c
===================================================================
--- linux-2.6.32.27.orig/net/8021q/vlan_dev.c
+++ linux-2.6.32.27/net/8021q/vlan_dev.c
@@ -830,3 +830,8 @@ void vlan_setup(struct net_device *dev)
 
 	memset(dev->broadcast, 0, ETH_ALEN);
 }
+
+unsigned short vlan_dev_get_vid(struct net_device *dev)
+{
+       return vlan_dev_info(dev)->vlan_id;
+}
Index: linux-2.6.32.27/net/bridge/br.c
===================================================================
--- linux-2.6.32.27.orig/net/bridge/br.c
+++ linux-2.6.32.27/net/bridge/br.c
@@ -22,6 +22,9 @@
 
 #include "br_private.h"
 
+extern int br_pkt_fwd_filter_register(void);
+extern int br_pkt_fwd_filter_deregister(void);
+
 int (*br_should_route_hook)(struct sk_buff *skb);
 
 static const struct stp_proto br_stp_proto = {
@@ -61,6 +64,10 @@ static int __init br_init(void)
 	err = br_netlink_init();
 	if (err)
 		goto err_out4;
+ 
+        err = br_pkt_fwd_filter_register();
+        if (err)
+                goto err_out4;
 
 	brioctl_set(br_ioctl_deviceless_stub);
 	br_handle_frame_hook = br_handle_frame;
@@ -85,6 +92,8 @@ err_out:
 
 static void __exit br_deinit(void)
 {
+	br_pkt_fwd_filter_deregister();
+
 	stp_proto_unregister(&br_stp_proto);
 
 	br_netlink_fini();
Index: linux-2.6.32.27/net/bridge/br_forward.c
===================================================================
--- linux-2.6.32.27.orig/net/bridge/br_forward.c
+++ linux-2.6.32.27/net/bridge/br_forward.c
@@ -16,6 +16,8 @@
 #include <linux/skbuff.h>
 #include <linux/if_vlan.h>
 #include <linux/netfilter_bridge.h>
+#include <linux/miscdevice.h>
+#include <net/br_pkt_fwd_filter.h>
 #include "br_private.h"
 
 /* Don't forward packets to originating port or forwarding diasabled */
@@ -64,21 +65,73 @@ static void __br_deliver(const struct ne
 			br_forward_finish);
 }
 
+extern unsigned short vlan_dev_get_vid(struct net_device *dev);
+
 static void __br_forward(const struct net_bridge_port *to, struct sk_buff *skb)
 {
 	struct net_device *indev;
+        int vid;
+        struct packet_fwd_filter *from_filter, *to_filter;
+        unsigned char from_grp, to_grp;
 
 	if (skb_warn_if_lro(skb)) {
 		kfree_skb(skb);
 		return;
 	}
 
+	/* forwarding between the same group is denied */
+	from_grp = skb->dev->fwd_grp;
+	to_grp = to->dev->fwd_grp;
+	if (from_grp & to_grp)
+		goto out;
+
+	/*
+	 * Packets from LAN/WLAN to WAN is controlled as below.
+	 * Check if VID of egress port is belong to pkt_fwd_filter of
+	 * the ingress port. (1: forward, 0: drop)
+	 */
+	from_filter = skb->dev->pkt_fwd_filter;
+	if((to_grp & NETDEV_GRP_WAN) &&
+		(from_grp != NETDEV_GRP_IGNORE) &&
+		(from_filter)) {
+		if (to->dev->priv_flags & IFF_802_1Q_VLAN) {
+			vid = vlan_dev_get_vid(to->dev);
+			if (!(from_filter->vid_map[vid >> 3] & (1 << (vid & 0x07))))
+				goto out;
+		} else {
+			if (!(from_filter->vid_map[0] & 0x01))
+				goto out;
+		}
+	}
+
+	/*
+	 * Packets from WAN to LAN/WLAN is controlled as below.
+	 * Check if VID of ingress port is belong to pkt_fwd_filter of
+	 * the egress port. (1: forward, 0: drop)
+	 */
+	to_filter = to->dev->pkt_fwd_filter;
+	if((from_grp & NETDEV_GRP_WAN) &&
+		(to_grp != NETDEV_GRP_IGNORE) &&
+		(to_filter)) {
+		if (skb->dev->priv_flags & IFF_802_1Q_VLAN) {
+			vid = vlan_dev_get_vid(skb->dev);
+			if (!(to_filter->vid_map[vid >> 3] & (1 << (vid & 0x07))))
+				goto out;
+		} else {
+			if (!(to_filter->vid_map[0] & 0x01))
+				goto out;
+		}
+	}
+
 	indev = skb->dev;
 	skb->dev = to->dev;
 	skb_forward_csum(skb);
 
 	NF_HOOK(PF_BRIDGE, NF_BR_FORWARD, skb, indev, skb->dev,
 			br_forward_finish);
+	return;
+out:
+	kfree_skb(skb);
 }
 
 /* called with rcu_read_lock */
@@ -151,3 +204,168 @@ void br_flood_forward(struct net_bridge 
 {
 	br_flood(br, skb, __br_forward);
 }
+
+static long br_pkt_fwd_filter_ioctl(struct file *file,
+                          unsigned int cmd, unsigned long arg)
+{
+        void __user *argp = (void __user *)arg;
+        BR_FWD_PKT_FT_CMD_T br_cmd;
+        struct net_device *dev;
+        int i, vid, mode;
+
+        if (cmd != SIOCDEVPRIVATE) {
+            printk("It is not private command (0x%X). cmd = (0x%X)\n",
+                    SIOCDEVPRIVATE, cmd);
+            return -EOPNOTSUPP;
+        }
+
+        if (copy_from_user((void *)&br_cmd, argp, sizeof(br_cmd))) {
+            printk("Copy from user space fail\n");
+            return -EFAULT;
+        }
+
+        br_cmd.netdev_name[IFNAMSIZ-1] = '\0';
+        dev = dev_get_by_name(&init_net, br_cmd.netdev_name);
+        if(!dev) {
+                printk("Unknown net device: %s\n", br_cmd.netdev_name);
+                return -EPERM;
+        }
+
+        switch (br_cmd.cmd) {
+        case PKT_FWD_FT_RESET:
+                dev->fwd_grp = NETDEV_GRP_IGNORE;
+                if(dev->pkt_fwd_filter) {
+                        kfree(dev->pkt_fwd_filter);
+                        dev->pkt_fwd_filter = NULL;
+                }
+                break;
+
+        case PKT_FWD_FT_RAW_SET:
+                dev->fwd_grp = br_cmd.fwd_grp;
+                if(!dev->pkt_fwd_filter) {
+                        dev->pkt_fwd_filter =
+                                kmalloc(sizeof(struct packet_fwd_filter),
+                                        GFP_KERNEL);
+                        if(!dev->pkt_fwd_filter) {
+                                dev_put(dev);
+                                return -ENOMEM;
+                        }
+                }
+                memcpy(dev->pkt_fwd_filter->vid_map, br_cmd.vid_map,
+                        BR_PKT_FWD_FT_VLAN_ARRAY_LEN);
+                break;
+
+        case PKT_FWD_FT_RAW_GET:
+                br_cmd.fwd_grp = dev->fwd_grp;
+                if(dev->pkt_fwd_filter) {
+                        memcpy(br_cmd.vid_map, dev->pkt_fwd_filter->vid_map,
+                                BR_PKT_FWD_FT_VLAN_ARRAY_LEN);
+                } else {
+                        for (i = 0; i < BR_PKT_FWD_FT_VLAN_ARRAY_LEN; i++)
+                                br_cmd.vid_map[i] = 0xFF;
+                }
+
+                if (copy_to_user(argp, (void *)&br_cmd, sizeof(br_cmd))) {
+                    printk("Copy to user space fail\n");
+                    dev_put(dev);
+                    return -EFAULT;
+                }
+
+                break;
+
+        case PKT_FWD_FT_ETH_GRP_SET:
+                dev->fwd_grp = br_cmd.fwd_grp;
+                break;
+
+        case PKT_FWD_FT_ETH_GRP_GET:
+                br_cmd.fwd_grp = dev->fwd_grp;
+
+                if (copy_to_user(argp, (void *)&br_cmd, sizeof(br_cmd))) {
+                    printk("Copy to user space fail\n");
+                    dev_put(dev);
+                    return -EFAULT;
+                }
+
+                break;
+
+        case PKT_FWD_FT_ETH_VLAN_SET:
+                if(!dev->pkt_fwd_filter) {
+                        dev->pkt_fwd_filter =
+                                kzalloc(sizeof(struct packet_fwd_filter),
+                                        GFP_KERNEL);
+                        if(!dev->pkt_fwd_filter) {
+                                dev_put(dev);
+                                return -ENOMEM;
+                        }
+                }
+                /* translate VID to bit offset */
+                vid = br_cmd.vlan_mode.vid;
+                if (br_cmd.vlan_mode.mode)      /* 1: forward */
+                        dev->pkt_fwd_filter->vid_map[vid >> 3] |=
+                                (1 << (vid & 0x07));
+                else                            /* 0: drop */
+                        dev->pkt_fwd_filter->vid_map[vid >> 3] &=
+                                ~(1 << (vid & 0x07));
+                break;
+        case PKT_FWD_FT_ETH_VLAN_GET:
+                if(dev->pkt_fwd_filter) {
+                        /* translate VID to bit offset */
+                        vid = br_cmd.vlan_mode.vid;
+                        if (dev->pkt_fwd_filter->vid_map[vid >> 3] &
+                                (1 << (vid & 0x07)))    /* 1: forward */
+                                br_cmd.vlan_mode.mode = 1;
+                        else                            /* 0: drop */
+                                br_cmd.vlan_mode.mode = 0;
+                        }
+
+                if (copy_to_user(argp, (void *)&br_cmd, sizeof(br_cmd))) {
+                    printk("Copy to user space fail\n");
+                        dev_put(dev);
+                        return -EFAULT;
+                }
+
+                break;
+        default:
+                dev_put(dev);
+                return -EPERM;
+        }
+
+        dev_put(dev);
+        return 0;
+
+}
+
+
+static int br_pkt_fwd_filter_open(struct inode *inode, struct file *file)
+{
+        return 0;
+}
+
+static int br_pkt_fwd_filter_release(struct inode *inode, struct file *file)
+{
+        return 0;
+}
+
+static struct file_operations br_pkt_fwd_filter_fops = {
+        .owner = THIS_MODULE,
+        .unlocked_ioctl = br_pkt_fwd_filter_ioctl,
+        .open = br_pkt_fwd_filter_open,
+        .release = br_pkt_fwd_filter_release,
+};
+
+static struct miscdevice br_pkt_fwd_filter_miscdev = {
+        .minor = MISC_DYNAMIC_MINOR,
+        .name = BR_PKT_FWD_FT_DRIVER_NAME,
+        .fops = &br_pkt_fwd_filter_fops,
+};
+
+int br_pkt_fwd_filter_register(void)
+{
+        return misc_register(&br_pkt_fwd_filter_miscdev);
+}
+
+int br_pkt_fwd_filter_deregister(void)
+{
+        return misc_deregister(&br_pkt_fwd_filter_miscdev);
+}
+
