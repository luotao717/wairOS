Index: uci-2011-01-19.1/delta.c
===================================================================
--- uci-2011-01-19.1.orig/delta.c	2011-01-20 21:28:46.000000000 +0800
+++ uci-2011-01-19.1/delta.c	2011-11-30 14:21:20.717271295 +0800
@@ -180,8 +180,10 @@
 	case UCI_CMD_CHANGE:
 		UCI_INTERNAL(uci_set, ctx, &ptr);
 		e = ptr.last;
+/* wxb
 		if (!ptr.option && e && (cmd == UCI_CMD_ADD))
 			uci_to_section(e)->anonymous = true;
+*/
 		break;
 	}
 	return;
Index: uci-2011-01-19.1/list.c
===================================================================
--- uci-2011-01-19.1.orig/list.c	2011-01-20 21:28:46.000000000 +0800
+++ uci-2011-01-19.1/list.c	2011-11-30 14:22:13.938698000 +0800
@@ -10,8 +10,153 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
+ * wxb add for add section and set a alone name 2011.11.30
  */
 
+/*free bitmap when package free*/
+#define UCI_CONFIG_NAME_LEN  32
+#define UCI_CONFIG_NAME_ID_LEN  10
+#define UCI_CONFIG_NAME_MAX_NUM  (100*32)
+static int uci_free_section_id (struct uci_package *p)
+{
+   struct uci_package_section_bitmap *pb,*pbfree;
+   unsigned int count = 0;
+
+   pb = p->secbitmap.pnxt;
+   while(pb)
+     {
+        pbfree = pb ;
+        pb = pb->pnxt;
+        count++;
+        free(pbfree);
+     }
+   return 0;
+}
+/*add id to sectionbitmap*/
+static int uci_set_section_id(struct uci_package *p, unsigned int id)
+{
+   struct uci_context *ctx = p->ctx;
+   unsigned int offset=0;
+   unsigned int index=0;
+   unsigned count= 0;
+   struct uci_package_section_bitmap  *pb = &p->secbitmap , *pbpre = NULL;
+
+   index = id % 32 ;
+   offset = (id-index) / 32 + 1;
+
+   pbpre = pb;
+   while(pb)
+     {
+       count++;
+       if (offset == count )
+       	{
+       	  break;
+       	}
+
+       pbpre = pb;
+       pb = pb->pnxt;
+     }
+
+   if( count < offset )
+     {
+       pb = pbpre;
+       while(count < offset)
+         {
+             pb->pnxt = (struct uci_package_section_bitmap *)uci_malloc(ctx,sizeof(struct uci_package_section_bitmap ));
+	         pb = pb->pnxt;
+             count++;
+         }
+     }
+    pb->bitmap |= (unsigned int ) 0x01 << index;
+
+   return 0;
+}
+static int uci_get_section_id(struct uci_package *p ,unsigned int *id)
+{
+  struct uci_context *ctx= p->ctx;
+  unsigned int ii;
+  unsigned int offset=0;
+  struct uci_package_section_bitmap  *pb =&p->secbitmap, *pbpre= NULL;
+
+  *id = 0;
+
+  pbpre = pb;
+  while(pb)
+   {
+      for (ii=0;ii<32;ii++)
+        {
+           if ( !(pb->bitmap & ((unsigned int)0x01 << ii )))
+             {
+		        *id = offset*32 + ii;
+                return 0;
+             }
+        }
+
+      offset++;
+      pbpre = pb;
+      pb = pb->pnxt;
+    }
+   /*not find */
+   if ( ((offset+1) *32) > UCI_CONFIG_NAME_MAX_NUM )
+   	{
+   	   fprintf(stderr,"The alloc name by The section support  is no more than %d \n",UCI_CONFIG_NAME_MAX_NUM);
+	   return -1;
+   	}
+
+   pbpre->pnxt = (struct uci_package_section_bitmap *) uci_malloc(ctx,sizeof(struct uci_package_section_bitmap));
+
+   *id = offset * 32 ;
+
+   return 0;
+}
+static int uci_set_section_name_bymanual( struct uci_package *p, const char *type , const char *name )
+{
+	char *pstr;
+        unsigned id = 0;
+
+	/*check the name is alloc by system */
+	if (memcmp(name,type,strlen(type)) != 0 )
+	   {
+              return 0;
+           }
+        if ( strlen(name) <= strlen(type))
+          {
+	    return 0;
+          }
+	/* set the id to bitmap */
+        pstr = (char *)(name + strlen(type));
+        /*delete the char _*/
+        if ( *pstr != '_' )
+        	 {
+        	    return -1;
+        	 }
+        pstr++;
+        id  = (unsigned int) atoi(pstr);
+        return uci_set_section_id(p,id);
+}
+
+static int uci_get_section_name_bymanual( struct uci_package *p, const char *type ,char *name )
+{
+	unsigned int id=0;
+	int ret=0;
+	unsigned maxlen = UCI_CONFIG_NAME_LEN - UCI_CONFIG_NAME_ID_LEN -1 ;
+
+	if ( strlen(type) > maxlen)
+		{
+		    fprintf(stderr, "uci add the type string length must be no  more than %d \n", maxlen);
+		    return -1;
+		}
+        ret = uci_get_section_id(p,&id);
+	if (ret != 0 )
+           {
+             return -1;
+           }
+
+        sprintf(name,"%s_%u",type,id);
+
+	return 0;
+}
+
 static void uci_list_set_pos(struct uci_list *head, struct uci_list *ptr, int pos)
 {
 	struct uci_list *new_head = head;
@@ -33,7 +178,7 @@
 	ptr->next->prev = ptr;
 }
 
-/* 
+/*
  * uci_alloc_generic allocates a new uci_element with payload
  * payload is appended to the struct to save memory and reduce fragmentation
  */
@@ -196,6 +341,11 @@
 	strcpy(s->type, type);
 	if (name == NULL)
 		s->anonymous = true;
+	else
+          {
+             if (uci_set_section_name_bymanual(p,type,name) != 0 )
+                 return NULL;
+          }
 	p->n_section++;
 
 	uci_list_add(&p->sections, &s->e.list);
@@ -239,6 +389,8 @@
 	if(!p)
 		return;
 
+	uci_free_section_id(p);
+
 	if (p->path)
 		free(p->path);
 	uci_foreach_element_safe(&p->sections, tmp, e) {
@@ -320,7 +472,7 @@
 	else if (!uci_validate_type(name))
 		goto error;
 
-	/* if the given index is negative, it specifies the section number from 
+	/* if the given index is negative, it specifies the section number from
 	 * the end of the list */
 	if (idx < 0) {
 		c = 0;
@@ -527,15 +679,22 @@
 
 	return 0;
 }
-
 int uci_add_section(struct uci_context *ctx, struct uci_package *p, const char *type, struct uci_section **res)
 {
 	bool internal = ctx->internal;
 	struct uci_section *s;
+	char buf[UCI_CONFIG_NAME_LEN] ;
+        char *name;
 
 	UCI_HANDLE_ERR(ctx);
 	UCI_ASSERT(ctx, p != NULL);
-	s = uci_alloc_section(p, type, NULL);
+        if (uci_get_section_name_bymanual(p,type,buf) != 0 )
+           {
+             return -1;
+           }
+        name = uci_strdup(ctx,buf);
+	s = uci_alloc_section(p, type, name);
+/*	s = uci_alloc_section(p, type, NULL);*/
 	uci_fixup_section(ctx, s);
 	*res = s;
 	if (!internal && p->has_delta)
Index: uci-2011-01-19.1/uci.h
===================================================================
--- uci-2011-01-19.1.orig/uci.h	2011-11-30 14:21:20.665271710 +0800
+++ uci-2011-01-19.1/uci.h	2011-11-30 14:21:20.721272473 +0800
@@ -422,7 +422,12 @@
 	struct uci_list hooks;
 	struct uci_list plugins;
 };
-
+/*wxb add bitmap for name configuration*/
+struct uci_package_section_bitmap
+{
+	unsigned int bitmap;
+	struct uci_package_section_bitmap *pnxt;
+};
 struct uci_package
 {
 	struct uci_element e;
@@ -435,6 +440,7 @@
 	struct uci_backend *backend;
 	void *priv;
 	int n_section;
+	struct uci_package_section_bitmap secbitmap;
 	struct uci_list delta;
 	struct uci_list saved_delta;
 };
